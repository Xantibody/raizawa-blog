---
date: 2026-02-16 02:20
title: Rustの勉強[Rc<T> その2]
category: ぎじゅつ
draft: false
tags:
  - Rust
---

## はじめに

<https://doc.rust-jp.rs/book-ja/>
を読んでいる

- 光らせる飽きてきたな
- やる必要はあるけど別のこと考えるか

## お勉強

<https://doc.rust-jp.rs/book-ja/ch15-04-rc.html#:~:text=%E4%BB%A3%E3%82%8F%E3%82%8A%E3%81%AB%E3%80%81List%E3%81%AE%E5%AE%9A%E7%BE%A9%E3%82%92%E3%83%AA%E3%82%B9%E3%83%8815%2D18%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E3%80%81Box%3CT%3E%E3%81%AE%E7%AE%87%E6%89%80%E3%81%ABRc%3CT%3E%E3%82%92%E4%BD%BF%E3%81%86%E3%82%88%E3%81%86%E3%81%AB%E5%A4%89%E6%9B%B4%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20%E3%81%93%E3%82%8C%E3%81%A7%E5%90%84Cons%E5%88%97%E6%8C%99%E5%AD%90%E3%81%AF%E3%80%81%E5%80%A4%E3%81%A8List%E3%82%92%E6%8C%87%E3%81%99Rc%3CT%3E%E3%82%92%E4%BF%9D%E6%8C%81%E3%81%99%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82>

- ここから
  - あー複数の所有権をもてそうって話
  - 真相は謎

### メモ

> 値と`List`を指す`Rc<T>`を保持するようになりました

- なるほど、何がなるほどかはなぞだが

> bを作る際、 aの所有権を奪うのではなく、aが保持している`Rc<List>`をクローンします。

- ここ大事そうか

- そもそも`cons`ってどういう挙動するんだっけ

<https://docs.rs/cons/latest/cons/trait.Cons.html>

- なんじゃこりゃ
- んーなるほど
- `Cons<C, Q>`のCに値を入れてQに`cons`を入れていくわけか

```rust
enum List {
Cons(i32, Box<List>),
Nil,
}

use crate::List::{Cons, Nil};

fn main() {
let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
let b = Cons(3, Box::new(a));
let c = Cons(4, Box::new(a));
}
```

- で`Box`だとb,cにmoveしちゃうんだな

```rust
enum List {
Cons(i32, Rc<List>),
Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
let b = Cons(3, Rc::clone(&a));
let c = Cons(4, Rc::clone(&a));
}
```

- でこうするとcloneするから問題ないと
- 動きは理解した

```rust
fn main() {
let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
// "a作成後のカウント = {}"
println!("count after creating a = {}", Rc::strong_count(&a));
let b = Cons(3, Rc::clone(&a));
// "b作成後のカウント = {}"
println!("count after creating b = {}", Rc::strong_count(&a));
{
let c = Cons(4, Rc::clone(&a));
// "c作成後のカウント = {}"
println!("count after creating c = {}", Rc::strong_count(&a));
}
// "cがスコープを抜けた後のカウント = {}"
println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
```

- これはわかった
- どういう動きをするかだけは理解できたがなぜそれをするかわからん

- んー、geminiにきいた（最近信じてない）
- とりあえず`Box`との違いはムーブさせずに複数ヵ所から同じ値をポインタで参照できる

- あー参照カウントって今誰が参照しているかって話か

## まとめ

- めっちゃ分かりづらくてムカついた
- おそらく実態はポインタの先にある値を複数のスマートポインタから参照するだけ
- 今何個参照されているとか値が取れる
  - え？これだけ？は？

次ここ
<https://doc.rust-jp.rs/book-ja/ch15-05-interior-mutability.html>
