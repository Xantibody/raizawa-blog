---
date: 2026-02-03 18:50
title: Rustの勉強[イテレータその 2]
category: ぎじゅつ
draft: false
tags:
  - Rust
---

## はじめに

<https://doc.rust-jp.rs/book-ja/>
を読んでいる

- 今日も要点を光らせたい

## お勉強

https://doc.rust-jp.rs/book-ja/ch13-02-iterators.html#%E4%BB%96%E3%81%AE%E3%82%A4%E3%83%86%E3%83%AC%E3%83%BC%E3%82%BF%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89
ここから

### メモ

- 他のイテレータを生成するメソッドの章
- 確か前回は消費する話をした

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

> イテレータアダプタは怠惰で、ここでイテレータを消費する必要があるのです。

- `.map`だと`Vec<i32>`が作れないって話しだった
- じゃあ`.map`って何やってんだ？
- `collect()`が消費するのはわかった
- 理解した
  - `v1.iter().map(|x| x + 1).collect();`
  - mapの()内にクロージャ処理するのね
  - んでイテレータが返却される
  - vecにするにはcollectで消費して変換する必要がある

> 環境をキャプチャするクロージャを使用する

- ここのキャプチャって考えたが、moveすることなんだろうか
- キャプチャするってなんだよ
  - なるほど、クロージャ内部で使えるようにすることをキャプチャっていうのか
    - そこに参照とmoveがあると
- そもそもIterator traitはtraitだから当たり前に実装できるよな
  - vecがtraitを実装してるだけ
  - と思ったが`.iter()`を使っていた

https://doc.rust-lang.org/std/slice/struct.Iter.html

- iterはIter structを返しているらしい
- へぇ

https://doc.rust-lang.org/src/core/slice/iter.rs.html#142-150

- next関数意味わからんw

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        self.count += 1;

        if self.count < 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
```

- そうか、このnext関数は+1するから5になるまでは消費できるんだ

## まとめ

- まあなんとなくわかった
- next関数の実装の仕方によって挙動が変わるというのもわかった
- 各々にクロージャを適応できるのも理解した

次はここ
https://doc.rust-jp.rs/book-ja/ch13-03-improving-our-io-project.html#%E5%85%A5%E5%87%BA%E5%8A%9B%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E6%94%B9%E5%96%84%E3%81%99%E3%82%8B
