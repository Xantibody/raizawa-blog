---
date: 2026-01-14 22:38
title: Rustの勉強[自動テスト その2]
category: ぎじゅつ
draft: false
tags:
  - Rust
---

## はじめに

<https://doc.rust-jp.rs/book-ja/>
を読んでいる

- blogが壊れてなおった

### 今日読む場所

https://doc.rust-jp.rs/book-ja/ch11-01-writing-tests.html#assert%E3%83%9E%E3%82%AF%E3%83%AD%E3%81%A7%E7%B5%90%E6%9E%9C%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B

## お勉強

### メモ

> assertマクロを使用して==演算子を使用した式を渡すことで行うこともできます。 しかしながら、これはありふれたテストなので、標準ライブラリには1組のマクロ(assert_eq!とassert_ne!)が提供され、 このテストをより便利に行うことができます。

- なんかやっと便利マクロって感じがしてきたな
- `assert_ne!`ってなんの略だよって思ったがNot Equalだ

> 比較対象の値はPartialEqとDebugトレイトを実装していなければなりません。 すべての組み込み型と、ほぼすべての標準ライブラリの型はこれらのトレイトを実装しています。

- ということは自分で作った型にもテストが書きたいならこれを実装すればいいって話しか
  > 単純に構造体やenum定義に#[derive(PartialEq, Debug)]という注釈を追加するだけですみます。
- まじかよ、もっと簡単だった

> テスト関数にshould_panicという別の属性を追加することで達成できます。 この属性は、関数内のコードがパニックしたら、テストを通過させます。つまり、 関数内のコードがパニックしなかったら、テストは失敗するわけです。

- まあ、このへんも特段不思議なことはなく、期待値がでたかどうかって話やな

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
```

- あ、ここに書くんだ
- まあJavaと違って`Exception`に複数の型があるわけじゃないからこれだけでいいのか

```
    #[test]
    //予想値は100以下でなければなりません
    #[should_panic(expected = "Guess value must be less than or equal to 100")]
    fn greater_than_100() {
        Guess::new(200);
    }
```

- ああこれ何に使うんだろうって思っていたが、エラーの文字列の期待値を書いているだけか
- fmfm

> Result<T, E> を返すようなテストを書くと、?演算子をテストの中で使えるようになります。 これは、テスト内で何らかの工程がErrヴァリアントを返したときに失敗するべきテストを書くのに便利です

- ハイハイ、この変はResultでやったね
- 書けるようになったらかなり感覚的に実装できそうだな

- cargo testの引数か
  > テストは同時に実行されているので、テストが相互や共有された環境を含む他の共通の状態に依存してないことを確かめてください。 現在の作業対象ディレクトリや環境変数などですね。
- これなー
- 共通のDBとかDocker内で使ってると詰むよな

## まとめ

- 至極当然のことが書いてあり、それぞれの`Reuslt`や`panic!`の処理がわかった
- このへんは引越しのときにt-wadaさんのyoutube無限にみていたので理解していた
- それがわかって良かった
- 次はここ
  https://doc.rust-jp.rs/book-ja/ch11-02-running-tests.html#%E9%96%A2%E6%95%B0%E3%81%AE%E5%87%BA%E5%8A%9B%E3%82%92%E8%A1%A8%E7%A4%BA%E3%81%99%E3%82%8B
