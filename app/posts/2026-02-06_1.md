---
date: 2026-02-06 01:50
title: Rustの勉強[イテレータその 3]
category: ぎじゅつ
draft: false
tags:
  - Rust
---

## はじめに

<https://doc.rust-jp.rs/book-ja/>
を読んでいる

- 昨日、一番意図しないサボりが発生して継続できるか不安ありけり
- SKKサーバが起動しなくてとてもだるい

## お勉強

https://doc.rust-jp.rs/book-ja/ch13-03-improving-our-io-project.html
ここをやる

### メモ

- ざっくり読んだ
- あまりにも光らなさすぎてつらくなった

```rust
impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
```

- とりあえずこのcloneがよくないよねっていう問題提起

> イテレータについての新しい知識があれば、new関数をスライスを借用する代わりに、 引数としてイテレータの所有権を奪うように変更することができます。

- ほほう
- 引数の受け取り方を変えられるってことね

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });

    // --snip--
}
```

- `env::args()`がイテレータを返すからこう書けると
- collectは優秀で`:Vec<String>`を書いていればイテレータを`Vec<String>`にできる
  - 遅延評価だからね

> ひとたび、Config::newがイテレータの所有権を奪い、借用する添え字アクセス処理をやめたら、 cloneを呼び出して新しくメモリ確保するのではなく、イテレータからのString値をConfigにムーブできます。

- おそらくここが重要ポイントなんだな

```rust
impl Config {
    pub fn new(mut args: std::env::Args) -> Result<Config, &'static str> {
        // --snip--
```

- おおーなるほど
- `std::env::Args`がイテレータだからそれを受け取るってことね

## まとめ

- 今日はまったく文字が光らないところからスタートした
  - そっからどう紐解いていくかを考えてこの章が何をしたかったのか確認していった
    > とりあえずこのcloneがよくないよねっていう問題提起

- ここが一番の問題であることを理解して、構造体の受け取り方にイテレータを応用しようということが理解できた

明日はここを見てどういう実装になっていくかだけ確認する
https://doc.rust-jp.rs/book-ja/ch13-03-improving-our-io-project.html#%E6%B7%BB%E3%81%88%E5%AD%97%E3%81%AE%E4%BB%A3%E3%82%8F%E3%82%8A%E3%81%ABiterator%E3%83%88%E3%83%AC%E3%82%A4%E3%83%88%E3%81%AE%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B
