---
date: 2026-02-11 20:17
title: Rustの勉強[Derefトレイト その2]
category: ぎじゅつ
draft: false
tags:
  - Rust
---

## はじめに

<https://doc.rust-jp.rs/book-ja/>
を読んでいる

- 取り組み方に飽きてきたなーと感じる
  - ここを言い感じに工夫して飽きないようにする課題もある

## お勉強

https://doc.rust-jp.rs/book-ja/ch15-02-deref.html#%E9%96%A2%E6%95%B0%E3%82%84%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%A7%E6%9A%97%E9%BB%99%E7%9A%84%E3%81%AA%E5%8F%82%E7%85%A7%E5%A4%96%E3%81%97%E5%9E%8B%E5%BC%B7%E5%88%B6
ここから

### メモ

- ざっくりよむか
- 前回の自分を観察している
- んーなにを伝えたいかわからないな
- geminiに概要だけ聞くか

- 何をいっているか理解できなかったので概要だけまずまとめて貰った

> Rustの「参照外し型強制（Deref Coercion）」は、一言で言えば**「型が合わないときに、コンパイラが自動的に\*（参照外し）と&（再参照）を繰り返して、目的の型に合わせてくれる機能」**です。

- ほう

- この観点で読む
- これ文章で表してもらうよりコードのほうが理解しやすいんだろうな

> 参照外し型強制は、関数やメソッド呼び出しを書くプログラマが&や\*を多くの明示的な参照や参照外しとして追記する必要がないように、 Rustに追加されました。

- まーこのへんかな

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}

fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

- こういうコードがあるらしい

> Rustに参照外し型強制が実装されていなかったら、リスト15-12のコードの代わりにリスト15-13のコードを書き、型&MyBox<String>の値でhelloを呼び出さなければならなかったでしょう。

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

- なぜこうなるか理解すればいける気がしてきたな
- `Box<String>`って参照記述はできないんじゃねって思った
- そんなことはないが、型が合わなくなるらしい

> fn hello(name: &str)
> 関数は &str を欲しがっています。一方で、私たちが持っているのは &MyBox<String> です

- おお、この記述で今の状況が理解できたな
- そうなるとコンパイルできることがおかしい
- たしかに

> 「参照外し型強制」があるおかげで、コンパイラが裏で以下のように考えてくれます。
> 1「&MyBox が来たな。でも関数は &str を欲しがってるぞ」
> 2「MyBox は Deref を実装してるから、&String に変換できるな（一皮剥く）」
> 3「String も Deref を実装してるから、&str に変換できるな（二皮剥く）」
> 4「よし、&str になった！これなら関数に渡せるぞ」

- おおー、geminiやるじゃん
- 理解できた

## まとめ

- Derefトレイトを実装したやつらがスマートポインタである
  - `Box<T>`はそれだけが実装してある入れものという大枠のイメージ
- んでその`参照外し型強制制（Deref Coercion）`はそうやってマトリョーシカになっていく型を繙いて最後の型を提示する

- 蛇足として文字を光らせる取り組みで得たのはこの章が何をいいたいか理解できない時はじっくり読む必要があった
  - ここの切り替えが難しい
- 今回はこの何を伝えたかったかをgeminiに一行で要約してもらってから紐解けた
- この紐解く速度が上がればいいというのが知見としてわかった

次はここ  
https://doc.rust-jp.rs/book-ja/ch15-03-drop.html
