---
date: 2026-02-19 15:22
title: Rustの勉強[Weak<T> その2]
category: ぎじゅつ
draft: false
tags:
  - Rust
---

## はじめに

<https://doc.rust-jp.rs/book-ja/>
を読んでいる

- やば、気を抜くと光らせるの忘れるな

## お勉強

- artoのprやりすぎてしまって反省している
- こんなに難しいんだなとわかった
- 今日は優しめ15分

<https://doc.rust-jp.rs/book-ja/ch15-06-reference-cycles.html#%E5%BE%AA%E7%92%B0%E5%8F%82%E7%85%A7%E3%81%AF%E3%83%A1%E3%83%A2%E3%83%AA%E3%82%92%E3%83%AA%E3%83%BC%E3%82%AF%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%82%82%E3%81%82%E3%82%8B>

- ここやる

### メモ

- ちゃんと読んだらシンプルに循環してた
- 一応回避する方法ありそうな予感

```rust
fn main() {
let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    //       "aの最初の参照カウント = {}"
    println!("a initial rc count = {}", Rc::strong_count(&a));
    //       "aの次の要素は = {:?}"
    println!("a next item = {:?}", a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));

    //       "b作成後のaの参照カウント = {}"
    println!("a rc count after b creation = {}", Rc::strong_count(&a));
    //       "bの最初の参照カウント = {}"
    println!("b initial rc count = {}", Rc::strong_count(&b));
    //       "bの次の要素 = {:?}"
    println!("b next item = {:?}", b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&b);
    }

    //       "aを変更後のbの参照カウント = {}"
    println!("b rc count after changing a = {}", Rc::strong_count(&b));
    //       "aを変更後のaの参照カウント = {}"
    println!("a rc count after changing a = {}", Rc::strong_count(&a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // 次の行のコメントを外して循環していると確認してください;
    // スタックオーバーフローします
    // //       "aの次の要素 = {:?}"
    // println!("a next item = {:?}", a.tail());

}
```

```bash
$ cargo run
Compiling cons-list v0.1.0 (file:///projects/cons-list)
Finished dev [unoptimized + debuginfo] target(s) in 0.53s
Running `target/debug/cons-list`
a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
```

- なげーなと思ったがシンプルに参照countとか余計なものが多いだけで最後のコメントアウトだけだった

> この例で循環参照を作成してしまうという結果は、それほど悲壮なものではありません:
> 循環参照を作った直後にプログラムが終了するからです。しかしながら、 より複雑なプログラムが多くのメモリを循環で確保し長い間その状態を保ったら、プログラムは必要以上のメモリを使用し、 使用可能なメモリを枯渇させてシステムを参らせてしまう可能性があります。

- まーこれが怖いよな

- `Weak<T>`があるらしい
  - そういえばWeakって弱いか
  - Weak PointのWeak

> Weak<T>のupgradeメソッドを呼び出すことでこれをしてください。
> このメソッドはOption<Rc<T>>を返します。

- おおーなるほど、そらそうだわ
  - あるかどうかわからないから`Option`つかうよね
  - Rustのコンテキストがわかってきた

- ということはこいつも`Deref`を実装してないな

<https://doc.rust-jp.rs/book-ja/ch15-06-reference-cycles.html#%E5%AD%90%E4%BE%9B%E3%81%8B%E3%82%89%E8%A6%AA%E3%81%AB%E5%8F%82%E7%85%A7%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B>

```rust
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
value: i32,
parent: RefCell<Weak<Node>>,
children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
let leaf = Rc::new(Node {
value: 3,
parent: RefCell::new(Weak::new()),
children: RefCell::new(vec![]),
});

    //       "leafの親 = {:?}"
    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());

}
```

- 無理やり使っているように見えてならん

<https://doc.rust-jp.rs/book-ja/ch15-06-reference-cycles.html#strong_count%E3%81%A8weak_count%E3%81%B8%E3%81%AE%E5%A4%89%E6%9B%B4%E3%82%92%E5%8F%AF%E8%A6%96%E5%8C%96%E3%81%99%E3%82%8B>

> カウントや値のドロップを管理するロジックは全て、`Rc<T>`や`Weak<T>`とその`Drop`トレイトの実装に組み込まれています。
> `Node`の定義で子供から親への関係は`Weak<T>`参照になるべきと指定することで、 循環参照やメモリリークを引き起こさずに親ノードに子ノードを参照させたり、その逆を行うことができます。

- なるほどなー

<https://github.com/conao3/leaf.el>

- 関係ないけどこれ思いだした

> leaf作成後、そのRc<Node>の強カウントは1、弱カウントは0になります。
> 内側のスコープでbranchを作成し、 leafに紐付け、この時点でカウントを出力すると、branchのRc<Node>の強カウントは1、 弱カウントも1になります(leaf.parentがWeak<Node>でbranchを指しているため)。
> leafのカウントを出力すると、強カウントが2になっていることがわかります。
> branchが今は、 branch.childrenに格納されたleafのRc<Node>のクローンを持っているからですが、 それでも弱カウントは0でしょう。

- いや、いいたいことは分かるが文章だとつらいな...

## まとめ

- `Weak<T>`があるということがわかった
  - 循環参照を回避できる
- でもそもそも循環参照になってしまっているのなら作りが悪いよなって思ってしまうので頭に入ってこなかった

次はよいよ並行処理！！！！！！！！！

https://doc.rust-jp.rs/book-ja/ch16-00-concurrency.html
