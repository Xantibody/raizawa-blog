---
date: 2026-02-08 18:57
title: Rustの勉強[Box<T> その1]
category: ぎじゅつ
draft: false
tags:
  - Rust
---

## はじめに

<https://doc.rust-jp.rs/book-ja/>
を読んでいる

- 今日は電車の中でやってみている
- 下書きはobsidianで

## お勉強

### メモ

> 最も素直なスマートポインタはボックスであり、その型は`Box<T>`と記述されます。

- これスマートポインタだったのか
- うお、上から読んでしまった
- 光らせるぞ

- 必要があって使っているってことは分かるが、これ以上のことがわからん
- なんもわからん
- `Box`を使うとスタックではなくヒープに入れることができるらしい
- あれ？基本ヒープじゃなかったっけ
- スタックは早く取り出せるところだからランダムアクセス苦手みたいなイメージ
- あと可変もだめだったはず

- ほぼ会ってたっぽい、ヒープはポインタからデータを見に行くのか
- んで本題に戻るか

> コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時
> 多くのデータがあり、その所有権を移したいが、その際にデータがコピーされないようにしたい時
> 値を所有する必要があり、特定の型であることではなく、特定のトレイトを実装する型であることのみ気にかけている時

- さいごよくわからなかったな

> 3番目のケースはトレイトオブジェクトとして知られています。第17章の「トレイトオブジェクトで異なる型の値を許容する」の節は、 すべてその話題に捧げられています。

- くたばれクソッタレ

- 「ボックスで再帰的な型を可能にする」
- とりあえずこれが大事そうだな

- 所有権を転送するときはデータがスタック上でコピーされるときがあると

- 雰囲気分かるけどわからん、進める
- この議論あれか、最初からスタックに格納せずにヒープに置く方法っぽいな

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

- ほう
- ただ入れただけ

> ヒープに単独の値を置いても嬉しいことはほとんどないので、このように単独でボックスを使用することはあまりありません。

- おい、次だ次

> コンパイラは再帰的な型の値が必要とする領域を知ることができないのです。

- ここ光ってた
- 多分だいじ

> しかしながら、ボックスのサイズはわかっているので、再帰的な型の定義にボックスを挟むことで再帰的な型を作ることができます。

- ？？？
- 普通にほかの型も`Box`と同じ構造にすればサイズ分かるじゃんって思った
- `Box`にできてほかにできないことがわからない

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

- Lispの話が出てきてわけわからなくなった

> 非再帰的な型の値を格納するのに必要な領域をどうコンパイラが決定しているかを見ましょう。

- この辺が大事そうだな

## まとめ

- 結構むずかった
- スマートポインタの話がまったく出てこなかった
- とりあえずヒープを確保する入れ物ということは理解できた

次ここ
https://doc.rust-jp.rs/book-ja/ch15-01-box.html#%E9%9D%9E%E5%86%8D%E5%B8%B0%E7%9A%84%E3%81%AA%E5%9E%8B%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E3%82%92%E8%A8%88%E7%AE%97%E3%81%99%E3%82%8B
