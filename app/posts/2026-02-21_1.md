---
date: 2026-02-21 02:10
title: Rustの勉強[並行性 その1]
category: ぎじゅつ
draft: false
tags:
  - Rust
---

## はじめに

<https://doc.rust-jp.rs/book-ja/>
を読んでいる

## お勉強

- ポインタ終わった
  - 実装したらもうちょっと理解度はあがりそう
- 並行処理やる
- 恐れるな！並行性
  - タイトルがいい
- 結構ワクワクしている

<https://doc.rust-jp.rs/book-ja/ch16-00-concurrency.html>

### メモ

- さらっと読んでみる

> 並行性を安全かつ効率的に扱うことは、Rustの別の主な目標です。

- そうなんだ

> メモリ安全性を保証することと、並行性問題を回避することは、 異なる方法で解決すべき別々の課題だと考えていました。

- ほうほう

> 所有権と型システムは、 メモリ安全性と並行性問題を管理する役に立つ一連の強力な道具であることを発見しました。

- 発見する
  - `json`も発見された

> 多くの並行性エラーは、実行時エラーではなくコンパイル時エラーになります。

- すごすぎじゃん

> Rustは、自分の状況と必要性に適した方法が何であれ、問題をモデル化するためのいろんな道具を備えています。

- ここRustっぽい
  - 機能多すぎじゃね?って議論されていたの思い出した

<https://doc.rust-jp.rs/book-ja/ch16-01-threads.html#%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%90%8C%E6%99%82%E3%81%AB%E8%B5%B0%E3%82%89%E3%81%9B%E3%82%8B>

- とりあえず光らせとくか
  - `spawn`とか`join`がでてくるな
  - ちょろっとやった`tokio`の並行処理にあったわこんなの
  - `move`クロージャの使い方は知りたかった

- ほうほう
  - `spawn`でスレッド作って
  - `join`で結果をマージして
  - `move`でなんかする？
  - と読めた
- なので`move`がわからない

> `thread::spawn`に渡されるクロージャでは、`move`キーワードを多用することになるでしょう。 そうすることで、クロージャは環境から使用する値の所有権を奪い、あるスレッドから別のスレッドに値の所有権を移すからです。

- ひとつのスレッドに所有権を集めておいたほうがいいってことかな

<https://doc.rust-jp.rs/book-ja/ch00-00-introduction.html#ferris>

- これはじめてしった
  - わかりずら

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        //       "こちらがベクタ: {:?}"
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

- かなり読める

> クロージャは`v`を使用しているので、`v`をキャプチャし、クロージャの環境の一部にしています。 `thread::spawn`はこのクロージャを新しいスレッドで走らせるので、 その新しいスレッド内で`v`にアクセスできるはずです。しかし、このコードをコンパイルすると、 以下のようなエラーが出ます:

```bash
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function
(エラー: クロージャは現在の関数よりも長生きするかもしれませんが、現在の関数が所有している`v`を借用しています)
 --> src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
  |                                  (借用されている値`v`より長生きするかもしれません)
7 |         println!("Here's a vector: {:?}", v);
  |                                           - `v` is borrowed here
  |                                            (`v`はここで借用されています)
  |
note: function requires argument type to outlive `'static`
(注釈: 関数は引数型が`'static`より長生きすることを要求しています)
 --> src/main.rs:6:18
  |
6 |       let handle = thread::spawn(|| {
  |  __________________^
7 | |         println!("Here's a vector: {:?}", v);
8 | |     });
  | |______^
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
(ヘルプ: `v`(や他の参照されている変数)の所有権をクロージャに奪わせるには、`move`キーワードを使用してください)
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++

For more information about this error, try `rustc --explain E0373`.
error: could not compile `threads` (bin "threads") due to 1 previous error
```

- ほー

> コンパイラには、立ち上げたスレッドがどのくらいの期間走るのかわからないので、 `v`への参照が常に有効であるか把握できないのです。

- そらそうだ
  - 平行で動くなら尚更

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

- こうしてみる

```bash
$ cargo run
   Compiling threads v0.1.0 (file:///projects/threads)
error[E0382]: use of moved value: `v`
(エラー: ムーブされた値の使用: `v`)
  --> src/main.rs:10:10
   |
4  |     let v = vec![1, 2, 3];
   |         - move occurs because `v` has type `Vec<i32>`, which does not implement the `Copy` trait
   |          (`v`は`Copy`トレイトを実装しない`Vec<i32>`型を持つので、ムーブが発生します)
5  |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved into closure here
   |                                       (値はここでクロージャ内にムーブされます)
7  |         println!("Here's a vector: {:?}", v);
   |                                           - variable moved due to use in closure
   |                                            (変数はクロージャ内で使用されているためムーブされます)
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |           (値はここでムーブ後に使用されています)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `threads` (bin "threads") due to 1 previous error
```

- こうなるらしい
- はえー
- `move`もそうだけど`copy`トレイトがあるかどうかで判断しているんだな

## まとめ

- 並行処理で所有権を使うことは有効だった
- `spawn`、`join`、`move`クロージャが紹介されていた

次はここの`spawn`と`join`の認識ミスがないかを確認する

<https://doc.rust-jp.rs/book-ja/ch16-01-threads.html>

問題

- `move`は何で使うのか
