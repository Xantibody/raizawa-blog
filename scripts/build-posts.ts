/**
 * Build script to generate posts data with rendered HTML.
 * This runs before vite build to avoid bundling Shiki in the worker.
 */
import { readdirSync, readFileSync, writeFileSync } from "fs";
import { join } from "path";
import * as yaml from "js-yaml";
import MarkdownIt from "markdown-it";
import Shiki from "@shikijs/markdown-it";
import {
  transformerNotationDiff,
  transformerNotationHighlight,
  transformerNotationErrorLevel,
} from "@shikijs/transformers";
import type { ShikiTransformer } from "shiki";
import { fetchOGP, generateOGPCard } from "../app/lib/ogp";

interface PostMeta {
  slug: string;
  title: string;
  date: string;
  category: string;
  tags: string[];
  draft: boolean;
}

interface Post {
  meta: PostMeta;
  content: string;
  html: string;
}

function detectStandaloneURLs(markdown: string): string[] {
  const urls: string[] = [];
  let match;

  const autolinkRegex = /^<(https?:\/\/[^\s>]+)>$/gm;
  while ((match = autolinkRegex.exec(markdown)) !== null) {
    urls.push(match[1]);
  }

  const standaloneRegex = /^(https?:\/\/[^\s]+)$/gm;
  while ((match = standaloneRegex.exec(markdown)) !== null) {
    urls.push(match[1]);
  }

  return [...new Set(urls)];
}

function transformerMetaTitle(): ShikiTransformer {
  return {
    name: "meta-title",
    pre(node) {
      const meta = this.options.meta?.__raw;
      if (!meta) return;

      const match = meta.match(/title=["']([^"']+)["']/);
      if (match) {
        const title = match[1];
        node.children.unshift({
          type: "element",
          tagName: "div",
          properties: { class: "code-title" },
          children: [{ type: "text", value: title }],
        });
      }
    },
  };
}

function parseFrontmatter(fileContents: string): { data: Record<string, any>; content: string } {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
  const match = fileContents.match(frontmatterRegex);

  if (!match) {
    return { data: {}, content: fileContents };
  }

  const [, frontmatter, content] = match;
  const data = yaml.load(frontmatter) as Record<string, any>;

  return { data, content };
}

async function main() {
  const postsDirectory = join(process.cwd(), "app/posts");
  const outputPath = join(process.cwd(), "app/lib/posts-data.ts");

  // Initialize markdown-it with Shiki
  const md = MarkdownIt({ html: true, breaks: true });
  md.enable("strikethrough");
  md.use(
    await Shiki({
      theme: "github-dark",
      transformers: [
        transformerNotationDiff(),
        transformerNotationHighlight(),
        transformerNotationErrorLevel(),
        transformerMetaTitle(),
      ],
    }),
  );

  // Read and process all posts
  const fileNames = readdirSync(postsDirectory).filter((f) => f.endsWith(".md"));
  const posts: Post[] = [];

  for (const fileName of fileNames) {
    const slug = fileName.replace(/\.md$/, "");
    const fullPath = join(postsDirectory, fileName);
    const fileContents = readFileSync(fullPath, "utf8");
    const { data, content } = parseFrontmatter(fileContents);

    const meta: PostMeta = {
      slug,
      title: data.title || slug,
      date: data.date || "",
      category: data.category || "",
      tags: data.tags || [],
      draft: data.draft || false,
    };

    if (meta.draft) continue;

    // Detect standalone URLs and fetch OGP
    const urls = detectStandaloneURLs(content);
    const ogpResults = await Promise.all(
      urls.map(async (url) => ({
        url,
        ogp: await fetchOGP(url),
      })),
    );

    // Replace standalone URLs with OGP cards
    let processedContent = content;
    for (const { url, ogp } of ogpResults) {
      const ogpCard = generateOGPCard(ogp);
      const escapedUrl = url.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      processedContent = processedContent
        .replace(new RegExp(`^<${escapedUrl}>$`, "gm"), ogpCard)
        .replace(new RegExp(`^${escapedUrl}$`, "gm"), ogpCard);
    }

    const html = md.render(processedContent);
    posts.push({ meta, content, html });
  }

  // Sort by date descending
  posts.sort((a, b) => {
    const dateA = new Date(a.meta.date.replace(" ", "T"));
    const dateB = new Date(b.meta.date.replace(" ", "T"));
    return dateB.getTime() - dateA.getTime();
  });

  // Generate TypeScript file (data only, types are in types.ts)
  const output = `// Auto-generated by scripts/build-posts.ts
// Do not edit manually

import type { Post } from './types'

export const posts: Post[] = ${JSON.stringify(posts, null, 2)}
`;

  writeFileSync(outputPath, output);
  console.log(`Generated ${posts.length} posts to ${outputPath}`);
}

main().catch(console.error);
