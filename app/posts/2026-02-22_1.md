---
date: 2026-02-22 03:30
title: Rustの勉強[並行性 その2]
category: ぎじゅつ
draft: false
tags:
  - Rust
---

## はじめに

<https://doc.rust-jp.rs/book-ja/>
を読んでいる

- 久し振りにMacで勉強している
- めちゃくちゃ眠い
- 夕方に起きたら店が閉まる時間が近くてこれできなかった
  - 夜にもやっていていくれ

## お勉強

https://doc.rust-jp.rs/book-ja/ch16-01-threads.html

- ここから
- `spawn`と`join`に認識のミスがないかだけ確認する

### メモ

- 普段は`tokio`みたいなcrateを使うって話があったがまあ勉強しておくのがよさそう

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            //       "やあ！立ち上げたスレッドから数字{}だよ！"
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        //       "やあ！メインスレッドから数字{}だよ！"
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

```shell
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
```

- あ、必ずしも`spawn`したスレッドからスタートするわけじゃないんだな
  - 記述順序的に先に動くのかと

> thread::sleepを呼び出すと、少々の間、スレッドの実行を止め、違うスレッドを走らせることができます。

- へぇ~
  - むちゃくちゃ重いときに使うんだろうか

> Rustプログラムのメインスレッドが完了するときには、立ち上げられたすべてのスレッドは、その実行が完了したかどうかにかかわらず、停止されることに注意してください。
> 立ち上げたスレッドにはiが9になるまで出力するよう指示しているのに、メインスレッドが終了する前の5までしか到達していません。

- あーたしかにね
- だから`join`使うんだっけか

https://doc.rust-jp.rs/book-ja/ch16-01-threads.html#join%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AB%E3%81%A7%E5%85%A8%E3%82%B9%E3%83%AC%E3%83%83%E3%83%89%E3%81%AE%E7%B5%82%E4%BA%86%E3%82%92%E5%BE%85%E3%81%A4

- やはり

>

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```

- `handle`ってなんだ

https://doc.rust-lang.org/std/thread/fn.spawn.html

- これか

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T + Send + 'static,
    T: Send + 'static,
```

- おいおい、`JoinHandle<T>`って戻り値もともとあるじゃん
- 先に紹介してくれ

> JoinHandleは、そのjoinメソッドを呼び出したときにスレッドの終了を待つ所有された値です。

- 書いてはあったが

- `handle.join().unwrap();`を次の処理の前に置いたりすると、そこまで終了を待つらしい
- なるほどなー

- 前回読んだmoveクロージャを俯瞰して思ったけど、関数としと切り出すのもなーというのはここでクロージャにすれないいんだな

https://doc.rust-jp.rs/book-ja/ch16-02-message-passing.html

> Go言語のドキュメンテーションのスローガンにある考えです: 「メモリを共有することでやり取りするな; 代わりにやり取りすることでメモリを共有しろ」

> Do not communicate by sharing memory; instead, share memory by communicating.

- これか

## まとめ

- `spawn`、 `join`の使い方はシンプルなのでわかった
  - 平行して処理する単位としてスレッドという名称が存在している
  - そのスレッドを生成するのが`spawn`
  - そのままスレッド内で処理してしまうと終わるまえに終了してしまう可能性があるので`join`を呼びだして終了待機のポイントを作っておく
- 蛇足だけど寝むいときって本当に集中はできないな
- 並行処理って実はあんまり使ったことなかったからゆっくりじっくりやるしかないかも

次はこれを光らせる

https://doc.rust-jp.rs/book-ja/ch16-02-message-passing.html
