---
date: 2026-02-18 00:58
title: Rustの勉強[RefCell<T> その2]
category: ぎじゅつ
draft: false
tags:
  - Rust
---

## はじめに

<https://doc.rust-jp.rs/book-ja/>
を読んでいる

## お勉強

- さてやるか
- もんだい、`RefCell`の特徴2つ

- 前回はこれらしい
  - 何だっけ
  - シングルスレッド用
  - 所有権をもつ
  - だったはず

<https://doc.rust-jp.rs/book-ja/ch15-05-interior-mutability.html#refcellt%E3%81%A7%E5%AE%9F%E8%A1%8C%E6%99%82%E3%81%AB%E5%80%9F%E7%94%A8%E3%82%92%E8%BF%BD%E3%81%84%E3%81%8B%E3%81%91%E3%82%8B>

- さてここから

- お、問題の答えも思い出したな
  - 不変を可変にできるやつや

### メモ

- エラー見てた

```rust
#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec<String>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
```

- `fn send(&self, message: &str)`
  - ここか
  - ここで不変として引数にしているのに、pushメソッドで内部を変更してしまっているからダメなんだな
  - んて`RefCell`の機能が不変を可変として扱うことか
- 理解してきたけど普通にダメそうだな

- んーなんかいっぱい文字書いてあるけど、これってRustの基本実装でどうしても表現できないときしか使わないほうがいいよな

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell<Vec<String>>,
    }

    impl MockMessenger {
        fn new() -> MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&self, message: &str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
```

- なるほどね、`Vec`側を囲むわけか

> `RefCell<T>`では、 `borrow`と`borrow_mut`メソッドを使用し、これらは`RefCell<T>`に所属する安全なAPIの一部です。 `borrow`メソッドは、スマートポインタ型の`Ref<T>`を返し、`borrow_mut`はスマートポインタ型の`RefMut<T>`を返します。

- ワロタ
  - 型いっぱい出てくるじゃん、バカヤロウ

> `Deref`を実装しているので、普通の参照のように扱うことができます。

- なるほどね
- あーこのメソッドは選択して不変参照か、可変参照か選べるのか

- 全体的に`Deref`トレイトがだいじ

```rust
impl Messenger for MockMessenger {
    fn send(&self, message: &str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
```

```shell
$ cargo test
Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
Finished test [unoptimized + debuginfo] target(s) in 0.91s
Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
(スレッド'tests::it_sends_an_over_75_percent_warning_message'は、src/lib.rs:60:53でパニックしました:
すでに借用されています: BorrowMutError)
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

failures:
tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
```

- んーなるほど
- 1回しか、借用できないけどビルドは通ってしまうわけね

> ここで行ったように、コンパイル時ではなく実行時に借用エラーをキャッチすることを選択するということは、 開発過程のより遅い段階でコードのミスを発見することになる可能性があることを意味します

- まあそうだよね
- buildで分かるからRustがいいわけだしね
- 時間切れ

## まとめ

- 時間かけているるけどまぁ使わなさそうだなと思う
- こんだけたいへんだからbuildで怒られようって啓示かもね
- `Deref`を実装しているのは`RefCell`じゃないんだと思う

<https://doc.rust-lang.org/std/cell/struct.RefCell.html>

- やっぱりね

次ここ
<https://doc.rust-jp.rs/book-ja/ch15-05-interior-mutability.html#rct%E3%81%A8refcellt%E3%82%92%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E5%8F%AF%E5%A4%89%E3%81%AA%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AB%E8%A4%87%E6%95%B0%E3%81%AE%E6%89%80%E6%9C%89%E8%80%85%E3%82%92%E6%8C%81%E3%81%9F%E3%81%9B%E3%82%8B>

`RefCell`から普遍や可変参照する方法
