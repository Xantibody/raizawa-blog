/**
 * Pre-build script to generate posts data with rendered HTML.
 * This runs before vite build to avoid bundling Shiki in the worker.
 */
import { readdirSync, readFileSync, writeFileSync } from 'fs'
import { join } from 'path'
import * as yaml from 'js-yaml'
import MarkdownIt from 'markdown-it'
import Shiki from '@shikijs/markdown-it'
import {
  transformerNotationDiff,
  transformerNotationHighlight,
  transformerNotationErrorLevel,
} from '@shikijs/transformers'
import type { ShikiTransformer } from 'shiki'

interface PostMeta {
  slug: string
  title: string
  date: string
  categories: string[]
  tags: string[]
  draft: boolean
}

interface Post {
  meta: PostMeta
  content: string
  html: string
}

function transformerMetaTitle(): ShikiTransformer {
  return {
    name: 'meta-title',
    pre(node) {
      const meta = this.options.meta?.__raw
      if (!meta) return

      const match = meta.match(/title=["']([^"']+)["']/)
      if (match) {
        const title = match[1]
        node.children.unshift({
          type: 'element',
          tagName: 'div',
          properties: { class: 'code-title' },
          children: [{ type: 'text', value: title }],
        })
      }
    },
  }
}

function parseFrontmatter(fileContents: string): { data: Record<string, any>; content: string } {
  const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/
  const match = fileContents.match(frontmatterRegex)

  if (!match) {
    return { data: {}, content: fileContents }
  }

  const [, frontmatter, content] = match
  const data = yaml.load(frontmatter) as Record<string, any>

  return { data, content }
}

async function main() {
  const postsDirectory = join(process.cwd(), 'app/posts')
  const outputPath = join(process.cwd(), 'app/lib/posts-data.ts')

  // Initialize markdown-it with Shiki
  const md = MarkdownIt({ html: true, breaks: true })
  md.use(
    await Shiki({
      theme: 'github-dark',
      transformers: [
        transformerNotationDiff(),
        transformerNotationHighlight(),
        transformerNotationErrorLevel(),
        transformerMetaTitle(),
      ],
    })
  )

  // Read and process all posts
  const fileNames = readdirSync(postsDirectory).filter((f) => f.endsWith('.md'))
  const posts: Post[] = []

  for (const fileName of fileNames) {
    const slug = fileName.replace(/\.md$/, '')
    const fullPath = join(postsDirectory, fileName)
    const fileContents = readFileSync(fullPath, 'utf8')
    const { data, content } = parseFrontmatter(fileContents)

    const meta: PostMeta = {
      slug,
      title: data.title || slug,
      date: data.date || '',
      categories: data.categories || [],
      tags: data.tags || [],
      draft: data.draft || false,
    }

    if (meta.draft) continue

    const html = md.render(content)
    posts.push({ meta, content, html })
  }

  // Sort by date descending
  posts.sort((a, b) => (a.meta.date < b.meta.date ? 1 : -1))

  // Generate TypeScript file
  const output = `// Auto-generated by scripts/build-posts.ts
// Do not edit manually

export interface PostMeta {
  slug: string
  title: string
  date: string
  categories: string[]
  tags: string[]
  draft: boolean
}

export interface Post {
  meta: PostMeta
  content: string
  html: string
}

export const posts: Post[] = ${JSON.stringify(posts, null, 2)}
`

  writeFileSync(outputPath, output)
  console.log(`Generated ${posts.length} posts to ${outputPath}`)
}

main().catch(console.error)
